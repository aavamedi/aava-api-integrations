// Generate TypeScript interfaces from OData metadata
// tslint:disable: no-console
import fs from "fs"
import { JSDOM } from "jsdom"

const findEntityTypeElements = (parent: Element): Element[] => {
  const elements = new Array<Element>()
  parent.childNodes.forEach(child => {
    if ("tagName" in child) {
      const childElement = (child as unknown) as Element
      if (childElement.tagName === "EntityType") {
        elements.push(childElement)
      }
      findEntityTypeElements(child).forEach(e => {
        elements.push(e)
      })
    }
  })
  return elements
}

const generateTypeNameBase = (propertyElement: Element): string => {
  return (
    propertyElement.getAttribute("Name") +
    (propertyElement.getAttribute("Nullable") === "false" ? "" : "?")
  )
}

const constructSimpleProperties = (entityTypeElement: Element): string[] => {
  const propertyElements = entityTypeElement.getElementsByTagName("Property")
  const properties = new Array<string>()
  for (let i = 0; i < propertyElements.length; i++) {
    const propertyElement = propertyElements.item(i)
    if (propertyElement !== null) {
      switch (propertyElement.getAttribute("Type")) {
        case "Edm.String":
          properties.push(`  ${generateTypeNameBase(propertyElement)}: string`)
          break
        case "Edm.Int32":
          properties.push(`  ${generateTypeNameBase(propertyElement)}: number`)
          break
        case "Edm.DateTimeOffset":
          // Dates need to be parsed when required, merely casting JSON to generated type does not do parsing
          properties.push(`  ${generateTypeNameBase(propertyElement)}: string`)
          break

        default:
          console.log(
            "Warning: Skipping unknown property of type " +
              propertyElement.getAttribute("Type")
          )
      }
    }
  }
  return properties
}

const constructNavigationProperties = (
  entityTypeElement: Element
): string[] => {
  const naviPropElements = entityTypeElement.getElementsByTagName(
    "NavigationProperty"
  )
  const properties = new Array<string>()
  for (let i = 0; i < naviPropElements.length; i++) {
    const naviPropElement = naviPropElements.item(i)
    if (naviPropElement !== null) {
      const type = naviPropElement.getAttribute("Type")
      if (type?.startsWith("Collection(")) {
        properties.push(
          `  ${naviPropElement.getAttribute("Name")}: ${type
            .substring(type.lastIndexOf(".") + 1)
            .replace(")", "")}[]`
        )
      } else {
        console.log("Warning: Unknown NavigationProperty " + type)
      }
    }
  }
  return properties
}

const generateTypes = (entityTypeElement: Element): string => {
  const entityName = entityTypeElement.getAttribute("Name")
  console.log("Generating entity " + entityName)

  return (
    `export type ${entityName} = {\n` +
    `${[
      ...constructSimpleProperties(entityTypeElement),
      ...constructNavigationProperties(entityTypeElement),
    ].join(",\n")}` +
    "\n}"
  )
}

const generateTypesFromODataMetadata = (
  metadataFilename: string,
  outputFilename: string
) => {
  console.log("Reading Sympa HR metadata from " + metadataFilename)
  const metadata = fs
    .readFileSync(metadataFilename, {
      encoding: "utf-8",
    })
    .toString()

  const metadataDocument = new JSDOM(metadata, { contentType: "text/xml" })
    .window.document

  const entityTypes = findEntityTypeElements(metadataDocument.documentElement)
  console.log(`Parsing ${entityTypes.length} entityTypes`)

  const code = entityTypes.map(generateTypes).join("\n")
  console.log("generated code", code)

  console.log("Writing code to " + outputFilename)
  fs.writeFileSync(
    outputFilename,
    "// This file was generated by sympa-codegen.ts\n" + code,
    { encoding: "utf-8" }
  )
  console.log("Done!")
}

const metadataFilename = process.argv[3]
if (!metadataFilename) {
  console.error("Usage: sympa-codegen <metadata-filename>")
} else {
  generateTypesFromODataMetadata(process.argv[3], "generated/sympa-types.ts")
}
